name: Copilot PR Monitor

# Run every minute, checks 3x with 20s intervals (effective 20s polling)
on:
  schedule:
    - cron: '* * * * *'
  workflow_dispatch:
    inputs:
      pr_number:
        description: Specific PR to check (optional)
        required: false
        type: string

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write

jobs:
  monitor-copilot-prs:
    runs-on: ubuntu-latest
    steps:
      - name: Check Copilot PRs (3x with 20s intervals)
        uses: actions/github-script@v7
        with:
          script: |
            const sleep = ms => new Promise(r => setTimeout(r, ms));

            async function checkPRs() {
              // Find open Copilot PRs
              let prsToCheck = [];

              if (context.payload.inputs && context.payload.inputs.pr_number) {
                prsToCheck = [parseInt(context.payload.inputs.pr_number, 10)];
              } else {
                const { data: prs } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  per_page: 20
                });

                prsToCheck = prs
                  .filter(pr => pr.user.login === 'Copilot' ||
                                pr.user.login.toLowerCase().includes('copilot'))
                  .map(pr => pr.number);
              }

              if (prsToCheck.length === 0) {
                core.info('No Copilot PRs to check');
                return;
              }

              core.info(`Checking PRs: ${prsToCheck.join(', ')}`);

              for (const prNumber of prsToCheck) {
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });

                const headSha = pr.head.sha;
                core.info(`PR #${prNumber}: ${pr.title} (${headSha.substring(0,7)})`);

                // 1. ALWAYS override DCO
                try {
                  await github.rest.repos.createCommitStatus({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    sha: headSha,
                    state: 'success',
                    context: 'dco',
                    description: 'DCO waived for Copilot'
                  });
                  core.info(`  DCO: overridden`);
                } catch (e) { /* ignore */ }

                // 2. Fix DCO labels
                const labels = pr.labels.map(l => l.name);
                if (labels.includes('dco-signoff: no')) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,
                      name: 'dco-signoff: no'
                    });
                    core.info(`  Label: removed dco-signoff: no`);
                  } catch (e) { /* ignore */ }
                }

                if (!labels.includes('dco-signoff: yes')) {
                  try {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,
                      labels: ['dco-signoff: yes']
                    });
                    core.info(`  Label: added dco-signoff: yes`);
                  } catch (e) { /* ignore */ }
                }

                // 3. Fix title if WIP
                if (pr.title.includes('[WIP]')) {
                  const newTitle = pr.title.replace('[WIP] ', '').replace('[WIP]', '').trim();
                  const finalTitle = /^[^\w]/.test(newTitle) ? newTitle : '\uD83D\uDC1B ' + newTitle;
                  try {
                    await github.rest.pulls.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber,
                      title: finalTitle
                    });
                    core.info(`  Title: updated to ${finalTitle}`);
                  } catch (e) { /* ignore */ }
                }

                // 4. ALWAYS remove WIP label if present (regardless of title)
                if (labels.includes('do-not-merge/work-in-progress')) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,
                      name: 'do-not-merge/work-in-progress'
                    });
                    core.info(`  Label: removed do-not-merge/work-in-progress`);
                  } catch (e) { /* ignore */ }
                }

                // 5. ALWAYS mark ready if draft
                if (pr.draft) {
                  try {
                    await github.graphql(`
                      mutation($prId: ID!) {
                        markPullRequestReadyForReview(input: {pullRequestId: $prId}) {
                          pullRequest { id }
                        }
                      }
                    `, { prId: pr.node_id });
                    core.info(`  Draft: marked ready`);
                  } catch (e) { /* ignore */ }
                }

                // 6. Check for build failures (check both check_runs AND status contexts)
                const { data: checkRuns } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: headSha
                });

                const { data: statusData } = await github.rest.repos.getCombinedStatusForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: headSha
                });

                // Check check_runs for failures
                const netlifyCheckFailed = checkRuns.check_runs.find(cr =>
                  cr.name && (cr.name.toLowerCase().includes('netlify') || cr.name.toLowerCase().includes('kubestellar')) &&
                  cr.conclusion === 'failure'
                );

                // Check status contexts for failures (Netlify uses this)
                const netlifyStatusFailed = statusData.statuses.find(s =>
                  s.context && s.context.toLowerCase().includes('netlify') &&
                  s.state === 'failure'
                );

                const netlifyFailed = netlifyCheckFailed || netlifyStatusFailed;
                const buildUrl = netlifyCheckFailed?.details_url || netlifyStatusFailed?.target_url || 'See PR checks';

                if (netlifyFailed) {
                  core.info(`  Build: FAILED`);

                  // Check if we already notified for this commit
                  const { data: comments } = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    per_page: 20
                  });

                  const alreadyNotified = comments.find(c =>
                    c.body.includes('Build Failed') &&
                    c.body.includes('@Copilot') &&
                    c.body.includes(headSha.substring(0, 7))
                  );

                  if (!alreadyNotified) {
                    const failureCount = comments.filter(c =>
                      c.body.includes('Build Failed') && c.body.includes('@Copilot')
                    ).length;

                    let msg = `## Build Failed (${headSha.substring(0,7)})\n\n@Copilot The build failed. Fix the error.\n\n**Logs:** ${buildUrl}`;

                    if (failureCount >= 3) {
                      msg += `\n\n**Attempt #${failureCount + 1}** - Review build logs carefully.`;
                    }

                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,
                      body: msg
                    });
                    core.info(`  Notified Copilot about failure`);

                    // Escalate after many failures
                    if (failureCount >= 5 && !labels.includes('ai-stuck')) {
                      await github.rest.issues.addLabels({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: prNumber,
                        labels: ['ai-stuck']
                      });
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: prNumber,
                        body: `## Needs Human Help\n\n@clubanderson PR has ${failureCount + 1} build failures. Copilot needs help.`
                      });
                      core.info(`  Escalated to human`);
                    }
                  }
                } else {
                  // Check both check_runs and status contexts for success
                  const netlifyCheckSuccess = checkRuns.check_runs.find(cr =>
                    cr.name && (cr.name.toLowerCase().includes('netlify') || cr.name.toLowerCase().includes('kubestellar')) &&
                    cr.conclusion === 'success'
                  );
                  const netlifyStatusSuccess = statusData.statuses.find(s =>
                    s.context && s.context.toLowerCase().includes('netlify') &&
                    s.state === 'success'
                  );

                  if (netlifyCheckSuccess || netlifyStatusSuccess) {
                    core.info(`  Build: PASSED`);
                  } else {
                    core.info(`  Build: pending or not started`);
                  }
                }
              }
            }

            // Run 2 times with 30s interval (staggered)
            core.info('=== Check 1/2 ===');
            await checkPRs();

            await sleep(30000);
            core.info('=== Check 2/2 ===');
            await checkPRs();

            core.info('Monitor complete');
