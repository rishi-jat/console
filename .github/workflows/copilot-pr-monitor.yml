name: Copilot PR Monitor

# Run every 2 minutes to check for Copilot PR issues
on:
  schedule:
    - cron: '*/2 * * * *'
  workflow_dispatch:
    inputs:
      pr_number:
        description: Specific PR to check (optional)
        required: false
        type: string

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write

jobs:
  monitor-copilot-prs:
    runs-on: ubuntu-latest
    steps:
      - name: Check Copilot PRs
        uses: actions/github-script@v7
        with:
          script: |
            // Find open Copilot PRs
            let prsToCheck = [];

            if (context.payload.inputs && context.payload.inputs.pr_number) {
              prsToCheck = [parseInt(context.payload.inputs.pr_number, 10)];
            } else {
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 20
              });

              prsToCheck = prs
                .filter(pr => pr.user.login === 'Copilot' ||
                              pr.user.login.toLowerCase().includes('copilot'))
                .map(pr => pr.number);
            }

            if (prsToCheck.length === 0) {
              core.info('No Copilot PRs to check');
              return;
            }

            core.info(`Checking PRs: ${prsToCheck.join(', ')}`);

            for (const prNumber of prsToCheck) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              const headSha = pr.head.sha;
              core.info(`PR #${prNumber}: ${pr.title} (${headSha.substring(0,7)})`);

              // 1. ALWAYS override DCO
              try {
                await github.rest.repos.createCommitStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: headSha,
                  state: 'success',
                  context: 'dco',
                  description: 'DCO waived for Copilot'
                });
                core.info(`  DCO: overridden`);
              } catch (e) { /* ignore */ }

              // 2. Fix labels
              const labels = pr.labels.map(l => l.name);
              if (labels.includes('dco-signoff: no')) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    name: 'dco-signoff: no'
                  });
                  core.info(`  Label: removed dco-signoff: no`);
                } catch (e) { /* ignore */ }
              }

              if (!labels.includes('dco-signoff: yes')) {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    labels: ['dco-signoff: yes']
                  });
                  core.info(`  Label: added dco-signoff: yes`);
                } catch (e) { /* ignore */ }
              }

              // 3. Fix title if WIP
              if (pr.title.includes('[WIP]')) {
                const newTitle = pr.title.replace('[WIP] ', '').replace('[WIP]', '').trim();
                const finalTitle = /^[^\w]/.test(newTitle) ? newTitle : '\uD83D\uDC1B ' + newTitle;
                try {
                  await github.rest.pulls.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    title: finalTitle
                  });
                  core.info(`  Title: updated to ${finalTitle}`);
                } catch (e) { /* ignore */ }

                // Remove WIP label
                if (labels.includes('do-not-merge/work-in-progress')) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,
                      name: 'do-not-merge/work-in-progress'
                    });
                  } catch (e) { /* ignore */ }
                }
              }

              // 4. Mark ready if draft
              if (pr.draft) {
                try {
                  await github.graphql(`
                    mutation($prId: ID!) {
                      markPullRequestReadyForReview(input: {pullRequestId: $prId}) {
                        pullRequest { id }
                      }
                    }
                  `, { prId: pr.node_id });
                  core.info(`  Draft: marked ready`);
                } catch (e) { /* ignore */ }
              }

              // 5. Check for build failures
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: headSha
              });

              const netlifyFailed = checkRuns.check_runs.find(cr =>
                cr.name && cr.name.toLowerCase().includes('netlify') &&
                cr.conclusion === 'failure'
              );

              if (netlifyFailed) {
                core.info(`  Build: FAILED`);

                // Check if we already notified for this commit
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  per_page: 10
                });

                const alreadyNotified = comments.find(c =>
                  c.body.includes('Build Failed') &&
                  c.body.includes('@Copilot') &&
                  c.body.includes(headSha.substring(0, 7))
                );

                if (!alreadyNotified) {
                  const failureCount = comments.filter(c =>
                    c.body.includes('Build Failed') && c.body.includes('@Copilot')
                  ).length;

                  let msg = `## Build Failed (${headSha.substring(0,7)})\n\n@Copilot The build failed. Fix the error.\n\n**Logs:** ${netlifyFailed.details_url || 'See PR checks'}`;

                  if (failureCount >= 3) {
                    msg += `\n\n**Attempt #${failureCount + 1}** - Review build logs carefully.`;
                  }

                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: msg
                  });
                  core.info(`  Notified Copilot about failure`);

                  // Escalate after many failures
                  if (failureCount >= 5 && !labels.includes('ai-stuck')) {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,
                      labels: ['ai-stuck']
                    });
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,
                      body: `## Needs Human Help\n\n@clubanderson PR has ${failureCount + 1} build failures. Copilot needs help.`
                    });
                    core.info(`  Escalated to human`);
                  }
                }
              } else {
                const netlifySuccess = checkRuns.check_runs.find(cr =>
                  cr.name && cr.name.toLowerCase().includes('netlify') &&
                  cr.conclusion === 'success'
                );

                if (netlifySuccess) {
                  core.info(`  Build: PASSED`);
                } else {
                  core.info(`  Build: pending or not started`);
                }
              }
            }

            core.info('Monitor complete');
