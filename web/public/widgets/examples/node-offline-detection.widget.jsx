/**
 * Node Offline Detection - Übersicht Widget
 *
 * Monitors Kubernetes nodes and alerts when nodes go offline or become unschedulable.
 *
 * Installation:
 * 1. Copy this file to ~/Library/Application Support/Übersicht/widgets/
 * 2. Ensure KC agent is running on localhost:8585
 * 3. Restart Übersicht
 *
 * Generated by KubeStellar Console - https://github.com/kubestellar/console
 */

const config = {
  agentEndpoint: 'http://127.0.0.1:8585',
  gpuEndpoint: 'http://localhost:8080/api/mcp/gpu-nodes',
  refreshInterval: 30000,
};

const styles = {
  card: {
    backgroundColor: 'rgba(17, 24, 39, 0.9)',
    backdropFilter: 'blur(12px)',
    borderRadius: '12px',
    border: '1px solid rgba(255, 255, 255, 0.1)',
    padding: '16px',
    fontFamily: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    color: '#f9fafb',
    boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1)',
    minWidth: '280px',
  },
  header: {
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
    marginBottom: '12px',
  },
  title: {
    fontSize: '14px',
    fontWeight: 600,
    color: '#f9fafb',
  },
  statusDot: {
    width: '8px',
    height: '8px',
    borderRadius: '50%',
  },
  statsGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(2, 1fr)',
    gap: '8px',
    marginBottom: '12px',
  },
  statBlock: {
    backgroundColor: 'rgba(31, 41, 55, 0.5)',
    borderRadius: '8px',
    padding: '8px 12px',
    textAlign: 'center',
  },
  statValue: {
    fontSize: '20px',
    fontWeight: 700,
    lineHeight: 1.2,
  },
  statLabel: {
    fontSize: '10px',
    color: '#9ca3af',
    textTransform: 'uppercase',
    letterSpacing: '0.05em',
    marginTop: '2px',
  },
  issuesList: {
    borderTop: '1px solid rgba(55, 65, 81, 0.5)',
    paddingTop: '12px',
    marginTop: '8px',
  },
  issueItem: {
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
    fontSize: '11px',
    padding: '6px 0',
    borderBottom: '1px solid rgba(55, 65, 81, 0.3)',
  },
  issueDot: {
    width: '6px',
    height: '6px',
    borderRadius: '50%',
    flexShrink: 0,
  },
  colors: {
    healthy: '#22c55e',
    warning: '#eab308',
    error: '#ef4444',
    info: '#3b82f6',
  },
};

// Fetch data from agent
export const command = async (dispatch) => {
  try {
    const [nodesRes, gpuRes] = await Promise.all([
      fetch(`${config.agentEndpoint}/nodes`).then(r => r.ok ? r.json() : { nodes: [] }).catch(() => ({ nodes: [] })),
      fetch(config.gpuEndpoint).then(r => r.ok ? r.json() : { nodes: [] }).catch(() => ({ nodes: [] })),
    ]);

    const nodes = nodesRes.nodes || [];
    const gpuNodes = gpuRes.nodes || [];

    // Detect offline nodes (not Ready or unschedulable)
    const offlineNodes = nodes.filter(n => n.status !== 'Ready' || n.unschedulable === true);

    // Detect GPU issues (nodes with 0 GPUs that have GPU type labels)
    const gpuIssues = gpuNodes.filter(n => n.gpuCount === 0 && n.gpuType);

    dispatch({
      type: 'DATA_LOADED',
      data: {
        totalNodes: nodes.length,
        offlineNodes,
        totalGPUs: gpuNodes.reduce((sum, n) => sum + (n.gpuCount || 0), 0),
        allocatedGPUs: gpuNodes.reduce((sum, n) => sum + (n.gpuAllocated || 0), 0),
        gpuIssues,
      },
    });
  } catch (error) {
    dispatch({ type: 'ERROR', error: error.message });
  }
};

export const refreshFrequency = config.refreshInterval;

export const initialState = {
  loading: true,
  error: null,
  data: null,
};

export const updateState = (event, previousState) => {
  switch (event.type) {
    case 'DATA_LOADED':
      return { loading: false, error: null, data: event.data };
    case 'ERROR':
      return { ...previousState, loading: false, error: event.error };
    default:
      return previousState;
  }
};

export const render = ({ state }) => {
  if (state.loading) {
    return (
      <div style={styles.card}>
        <div style={styles.header}>
          <div style={{ ...styles.statusDot, backgroundColor: styles.colors.info }} />
          <span style={styles.title}>Node Offline Detection</span>
        </div>
        <div style={{ color: '#9ca3af', fontSize: '12px' }}>Loading...</div>
      </div>
    );
  }

  if (state.error) {
    return (
      <div style={styles.card}>
        <div style={styles.header}>
          <div style={{ ...styles.statusDot, backgroundColor: styles.colors.error }} />
          <span style={styles.title}>Node Offline Detection</span>
        </div>
        <div style={{ color: styles.colors.error, fontSize: '12px' }}>Error: {state.error}</div>
      </div>
    );
  }

  const { totalNodes, offlineNodes, totalGPUs, allocatedGPUs, gpuIssues } = state.data;
  const hasIssues = offlineNodes.length > 0 || gpuIssues.length > 0;
  const statusColor = hasIssues ? styles.colors.error : styles.colors.healthy;

  return (
    <div style={styles.card}>
      <div style={styles.header}>
        <div style={{ ...styles.statusDot, backgroundColor: statusColor }} />
        <span style={styles.title}>Node Offline Detection</span>
      </div>

      <div style={styles.statsGrid}>
        <div style={styles.statBlock}>
          <div style={{ ...styles.statValue, color: offlineNodes.length > 0 ? styles.colors.error : styles.colors.healthy }}>
            {offlineNodes.length}
          </div>
          <div style={styles.statLabel}>Offline</div>
        </div>
        <div style={styles.statBlock}>
          <div style={{ ...styles.statValue, color: styles.colors.info }}>
            {totalNodes - offlineNodes.length}/{totalNodes}
          </div>
          <div style={styles.statLabel}>Nodes Ready</div>
        </div>
        <div style={styles.statBlock}>
          <div style={{ ...styles.statValue, color: styles.colors.healthy }}>
            {allocatedGPUs}/{totalGPUs}
          </div>
          <div style={styles.statLabel}>GPUs Used</div>
        </div>
        <div style={styles.statBlock}>
          <div style={{ ...styles.statValue, color: gpuIssues.length > 0 ? styles.colors.warning : styles.colors.healthy }}>
            {gpuIssues.length}
          </div>
          <div style={styles.statLabel}>GPU Issues</div>
        </div>
      </div>

      {hasIssues && (
        <div style={styles.issuesList}>
          <div style={{ fontSize: '10px', color: '#9ca3af', marginBottom: '8px', textTransform: 'uppercase' }}>
            Issues Detected
          </div>
          {offlineNodes.slice(0, 3).map((node, i) => (
            <div key={`node-${i}`} style={styles.issueItem}>
              <div style={{ ...styles.issueDot, backgroundColor: styles.colors.error }} />
              <span style={{ color: '#f9fafb', flex: 1 }}>{node.name}</span>
              <span style={{ color: '#9ca3af' }}>{node.status}</span>
            </div>
          ))}
          {gpuIssues.slice(0, 2).map((issue, i) => (
            <div key={`gpu-${i}`} style={styles.issueItem}>
              <div style={{ ...styles.issueDot, backgroundColor: styles.colors.warning }} />
              <span style={{ color: '#f9fafb', flex: 1 }}>{issue.name}</span>
              <span style={{ color: '#9ca3af' }}>GPU: 0/{issue.gpuType}</span>
            </div>
          ))}
          {(offlineNodes.length > 3 || gpuIssues.length > 2) && (
            <div style={{ fontSize: '10px', color: '#9ca3af', marginTop: '4px' }}>
              +{Math.max(0, offlineNodes.length - 3) + Math.max(0, gpuIssues.length - 2)} more issues
            </div>
          )}
        </div>
      )}

      {!hasIssues && (
        <div style={{ textAlign: 'center', padding: '8px', color: styles.colors.healthy, fontSize: '12px' }}>
          All nodes healthy
        </div>
      )}
    </div>
  );
};
