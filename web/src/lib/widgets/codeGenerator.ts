/**
 * Widget Code Generator
 *
 * Generates Übersicht widget code (.jsx) for cards, stats, and templates.
 */

import { WIDGET_CARDS, WIDGET_STATS, WIDGET_TEMPLATES } from './widgetRegistry'
import { generateWidgetStyles, generateWidgetShell } from './styleConverter'

export interface WidgetConfig {
  type: 'card' | 'stat' | 'template'
  cardType?: string
  statIds?: string[]
  templateId?: string
  apiEndpoint: string
  refreshInterval: number
  theme: 'dark' | 'light'
}

// Resolve the API endpoint for widget curl commands.
// For nightly E2E, use the public (no-auth) endpoint so widgets work without JWT.
function resolveWidgetEndpoint(apiEndpoint: string, cardApiPath: string): string {
  if (cardApiPath === '/api/nightly-e2e/runs') {
    return `${apiEndpoint}/api/public/nightly-e2e/runs`
  }
  return `${apiEndpoint}${cardApiPath}`
}

// Generate Übersicht widget code for a single card
export function generateCardWidget(
  cardType: string,
  apiEndpoint: string,
  refreshInterval: number = 30000
): string {
  const card = WIDGET_CARDS[cardType]
  if (!card) {
    throw new Error(`Unknown card type: ${cardType}`)
  }

  const curlUrl = resolveWidgetEndpoint(apiEndpoint, card.apiEndpoints[0])
  const widgetName = cardType.replace(/_/g, '-')
  // Derive the console frontend URL from the API endpoint
  const consoleUrl = apiEndpoint.replace(/\/api$/, '').replace(/:\d+$/, ':5174')
  const shellCode = generateWidgetShell(widgetName, consoleUrl)

  return `/**
 * ${card.displayName} Widget
 * ${card.description}
 *
 * Generated by KubeStellar Console
 * Install: Move to ~/Library/Application Support/Übersicht/widgets/
 * Drag the ⋮⋮ handle to reposition. Position is saved automatically.
 */

${shellCode}

// Fetch data via curl (Übersicht's WebKit does not support fetch)
export const command = \`/usr/bin/curl -s --connect-timeout 5 ${curlUrl} 2>/dev/null || echo '{"error":"Load failed"}'\`;

export const refreshFrequency = ${refreshInterval};

${generateWidgetStyles()}

${generateCardRenderFunction(cardType, card.displayName)}
`
}

// Generate render function for specific card type
function generateCardRenderFunction(cardType: string, displayName?: string): string {
  const card = WIDGET_CARDS[cardType]
  const title = displayName || card?.displayName || cardType

  // All render functions use ({ output }) pattern — Übersicht passes curl stdout as output string
  const parseBlock = `
  let data = null;
  let error = null;
  try {
    const trimmed = (output || '').trim();
    if (!trimmed || trimmed.includes('"error"')) {
      error = 'Load failed';
    } else {
      data = JSON.parse(trimmed);
    }
  } catch (e) {
    error = 'Parse error';
  }

  const containerStyle = {
    ...styles.card,
    position: 'absolute',
    top: widgetPosition.top + 'px',
    left: widgetPosition.left + 'px',
    pointerEvents: 'auto',
  };`

  // Wrap card content in the draggable container
  const wrapOpen = `
  return (
    <div style={{ position: 'relative', width: '100%', height: '100%' }}>
      <div className="widget-container" style={containerStyle}>
        <div className="drag-handle" style={styles.dragHandle} onMouseDown={handleDragStart} title="Drag to move">
          <span style={styles.dragIndicator}>⋮⋮</span>
        </div>`

  const wrapClose = `
      </div>
    </div>
  );`

  switch (cardType) {
    case 'cluster_health':
      return `
export const render = ({ output }) => {${parseBlock}

  if (error) {${wrapOpen}
        <div style={styles.cardTitle}>
          <span style={{...styles.statusDot, backgroundColor: styles.colors.error}} />
          ${card.displayName}
        </div>
        <span style={{color: styles.colors.error}}>Error: {error}</span>${wrapClose}
  }

  const clusters = data?.clusters || [];
  const healthy = clusters.filter(c => c.healthy !== false).length;
  const unhealthy = clusters.length - healthy;
${wrapOpen}
        <div style={styles.cardTitle}>
          <span style={{...styles.statusDot, backgroundColor: unhealthy > 0 ? styles.colors.warning : styles.colors.healthy}} />
          ${card.displayName}
        </div>
        <div style={styles.row}>
          <div style={{...styles.statBlock, borderLeft: \`3px solid \${styles.colors.healthy}\`}}>
            <span style={{...styles.statValue, color: styles.colors.healthy}}>{healthy}</span>
            <span style={styles.statLabel}>Healthy</span>
          </div>
          <div style={{...styles.statBlock, borderLeft: \`3px solid \${styles.colors.error}\`}}>
            <span style={{...styles.statValue, color: unhealthy > 0 ? styles.colors.error : styles.colors.info}}>{unhealthy}</span>
            <span style={styles.statLabel}>Unhealthy</span>
          </div>
        </div>${wrapClose}
};`

    case 'pod_issues':
      return `
export const render = ({ output }) => {${parseBlock}

  if (error) {${wrapOpen}
        <div style={styles.cardTitle}>
          <span style={{...styles.statusDot, backgroundColor: styles.colors.error}} />
          ${card.displayName}
        </div>
        <span style={{color: styles.colors.error}}>Error: {error}</span>${wrapClose}
  }

  const issues = data?.issues || data || [];
  const crashLoop = issues.filter(i => i.reason === 'CrashLoopBackOff').length;
  const oomKilled = issues.filter(i => i.reason === 'OOMKilled').length;
  const other = issues.length - crashLoop - oomKilled;
${wrapOpen}
        <div style={styles.cardTitle}>
          <span style={{...styles.statusDot, backgroundColor: issues.length > 0 ? styles.colors.warning : styles.colors.healthy}} />
          ${card.displayName}
        </div>
        <div style={{fontSize: '12px', color: '#9ca3af', marginBottom: '8px'}}>
          {issues.length} total issues
        </div>
        <div style={styles.column}>
          {crashLoop > 0 && (
            <div style={{...styles.row, padding: '4px 8px', backgroundColor: 'rgba(239, 68, 68, 0.1)', borderRadius: '4px'}}>
              <span style={{color: styles.colors.error, fontWeight: 600}}>{crashLoop}</span>
              <span style={{color: '#9ca3af', fontSize: '12px'}}>CrashLoopBackOff</span>
            </div>
          )}
          {oomKilled > 0 && (
            <div style={{...styles.row, padding: '4px 8px', backgroundColor: 'rgba(234, 179, 8, 0.1)', borderRadius: '4px'}}>
              <span style={{color: styles.colors.warning, fontWeight: 600}}>{oomKilled}</span>
              <span style={{color: '#9ca3af', fontSize: '12px'}}>OOMKilled</span>
            </div>
          )}
          {other > 0 && (
            <div style={{...styles.row, padding: '4px 8px', backgroundColor: 'rgba(59, 130, 246, 0.1)', borderRadius: '4px'}}>
              <span style={{color: styles.colors.info, fontWeight: 600}}>{other}</span>
              <span style={{color: '#9ca3af', fontSize: '12px'}}>Other</span>
            </div>
          )}
          {issues.length === 0 && (
            <div style={{color: styles.colors.healthy, fontSize: '14px'}}>No issues detected</div>
          )}
        </div>${wrapClose}
};`

    case 'nightly_e2e_status':
      return `
export const render = ({ output }) => {${parseBlock}

  if (error) {${wrapOpen}
        <div style={styles.cardTitle}>
          <span style={{...styles.statusDot, backgroundColor: styles.colors.error}} />
          Nightly E2E Status
        </div>
        <span style={{color: styles.colors.error}}>Error: {error}</span>${wrapClose}
  }

  const guides = data?.guides || [];
  const platforms = ['OCP', 'GKE', 'CKS'];
  const platformColors = { OCP: '#f97316', GKE: '#3b82f6', CKS: '#a855f7' };
  const conclusionColors = { success: '#22c55e', failure: '#ef4444', cancelled: '#6b7280', skipped: '#6b7280' };
  const totalGuides = guides.length;
  const failing = guides.filter(g => g.latestConclusion === 'failure').length;
  const allRuns = guides.flatMap(g => g.runs || []);
  const completedRuns = allRuns.filter(r => r.status === 'completed');
  const passedRuns = completedRuns.filter(r => r.conclusion === 'success');
  const passRate = completedRuns.length > 0 ? Math.round((passedRuns.length / completedRuns.length) * 100) : 0;
${wrapOpen}
        <div style={styles.cardTitle}>
          <span style={{...styles.statusDot, backgroundColor: failing > 0 ? '#ef4444' : '#22c55e'}} />
          Nightly E2E Status
        </div>
        <div style={{display: 'flex', gap: '16px', marginBottom: '10px'}}>
          <div>
            <div style={{fontSize: '20px', fontWeight: 700, color: '#a855f7'}}>{passRate}%</div>
            <div style={{fontSize: '10px', color: '#9ca3af'}}>Pass Rate</div>
          </div>
          <div>
            <div style={{fontSize: '20px', fontWeight: 700}}>{totalGuides}</div>
            <div style={{fontSize: '10px', color: '#9ca3af'}}>Guides</div>
          </div>
          <div>
            <div style={{fontSize: '20px', fontWeight: 700, color: failing > 0 ? '#ef4444' : '#22c55e'}}>{failing}</div>
            <div style={{fontSize: '10px', color: '#9ca3af'}}>Failing</div>
          </div>
        </div>
        {platforms.map(platform => {
          const platGuides = guides.filter(g => g.platform === platform);
          if (platGuides.length === 0) return null;
          return (
            <div key={platform} style={{marginBottom: '6px'}}>
              <div style={{color: platformColors[platform], fontWeight: 600, fontSize: '10px', marginBottom: '2px'}}>{platform}</div>
              {platGuides.map(g => {
                const workflowUrl = 'https://github.com/' + g.repo + '/actions/workflows/' + g.workflowFile;
                const runs = (g.runs || []).slice(0, 7);
                const completed = runs.filter(r => r.status === 'completed');
                const passed = completed.filter(r => r.conclusion === 'success').length;
                const failedAll = completed.filter(r => r.conclusion === 'failure');
                const gpuFails = failedAll.filter(r => r.failureReason === 'gpu_unavailable').length;
                const failed = failedAll.length;
                const lastRun = runs[0];
                const timeAgo = (ts) => {
                  if (!ts) return '';
                  const ms = Date.now() - new Date(ts).getTime();
                  const h = Math.floor(ms / 3600000);
                  if (h < 1) return Math.floor(ms / 60000) + 'm ago';
                  if (h < 24) return h + 'h ago';
                  return Math.floor(h / 24) + 'd ago';
                };
                const tooltip = g.guide + ' (' + platform + ')\\n' +
                  'Pass rate: ' + g.passRate + '% (' + passed + '/' + completed.length + ')\\n' +
                  (failed > 0 ? 'Failed: ' + failed + '\\n' : '') +
                  (lastRun ? 'Last run: ' + (lastRun.conclusion || lastRun.status) + ' ' + timeAgo(lastRun.updatedAt || lastRun.createdAt) : '');
                return (
                <div key={g.guide + g.platform} style={{display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '2px'}}>
                  <span className="tip-wrap" style={{width: '28px', fontSize: '10px', fontWeight: 600, color: '#94a3b8', cursor: 'pointer'}} onClick={() => run(\`open "\${workflowUrl}"\`)}>
                    <span className="tip">{tooltip}</span>
                    {g.acronym}
                  </span>
                  <span className="spark-tip-wrap" style={{width: '90px', cursor: 'default'}}>
                    <span className="spark-tip">
                      <div style={{fontWeight: 600, color: '#f1f5f9', marginBottom: 3}}>{g.guide}</div>
                      <div style={{color: platformColors[platform], fontSize: '8px', marginBottom: 4}}>{platform}</div>
                      <div style={{marginBottom: 2}}>Pass rate: <span style={{color: g.passRate >= 80 ? '#22c55e' : g.passRate >= 50 ? '#eab308' : '#ef4444', fontWeight: 600}}>{g.passRate}%</span> ({passed}/{completed.length})</div>
                      {failed > 0 && <div style={{marginBottom: 2}}>
                        <span style={{color: '#ef4444'}}>Failed: {failed - gpuFails}</span>
                        {gpuFails > 0 && <span style={{color: '#f59e0b', marginLeft: 6}}>GPU: {gpuFails}</span>}
                      </div>}
                      {lastRun && <div style={{marginBottom: 4}}>Last: {lastRun.conclusion || lastRun.status} {timeAgo(lastRun.updatedAt || lastRun.createdAt)}</div>}
                      {runs.length > 1 && (() => {
                        const sw = 150, sh = 28, sp = 10;
                        const pts = runs.map((rr, ii) => {
                          const isGpuFail = rr.conclusion === 'failure' && rr.failureReason === 'gpu_unavailable';
                          return {
                            x: sp + (runs.length > 1 ? ii * (sw - 2 * sp) / (runs.length - 1) : sw / 2),
                            y: rr.conclusion === 'success' ? 6 : rr.conclusion === 'failure' ? 22 : 14,
                            c: rr.status !== 'completed' ? '#60a5fa' : rr.conclusion === 'success' ? '#22c55e' : isGpuFail ? '#f59e0b' : rr.conclusion === 'failure' ? '#ef4444' : '#6b7280',
                          };
                        });
                        return (
                          <svg width={sw} height={sh} style={{display: 'block'}}>
                            <polyline points={pts.map(p => p.x + ',' + p.y).join(' ')} fill="none" stroke="#334155" strokeWidth="1.5" strokeLinejoin="round" />
                            {pts.map((p, pi) => <circle key={pi} cx={p.x} cy={p.y} r={3} fill={p.c} />)}
                            <text x={sp} y={sh} textAnchor="start" fontSize="6" fill="#475569">new</text>
                            <text x={sw - sp} y={sh} textAnchor="end" fontSize="6" fill="#475569">old</text>
                          </svg>
                        );
                      })()}
                      {runs.length === 1 && <div style={{fontSize: '8px', color: '#64748b'}}>Only 1 run — no trend yet</div>}
                    </span>
                    <span style={{fontSize: '10px', color: '#cbd5e1', display: 'inline-block', width: '90px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap'}}>{g.guide}</span>
                  </span>
                  <div style={{display: 'flex', gap: '2px', alignItems: 'center'}}>
                    {runs.map((r, i) => {
                      const isGpu = r.conclusion === 'failure' && r.failureReason === 'gpu_unavailable';
                      const isFailed = r.conclusion === 'failure';
                      const dotLabel = (r.conclusion || r.status) + (isGpu ? ' (GPU)' : '') + ' — ' + timeAgo(r.updatedAt || r.createdAt);
                      const dotColor = r.status !== 'completed' ? '#60a5fa' : isGpu ? '#f59e0b' : (conclusionColors[r.conclusion] || '#6b7280');
                      return (
                      <span key={i} className={'dot-tip-wrap' + (isFailed ? ' has-links' : '')} onClick={() => r.htmlUrl && run(\`open "\${r.htmlUrl}"\`)}>
                        <span className="tip">
                          {dotLabel}
                          {isFailed && r.htmlUrl && <span><br/><a href={r.htmlUrl + '#logs'} onClick={(e) => { e.stopPropagation(); run(\`open "\${r.htmlUrl}#logs"\`); }}>Logs</a><a href={r.htmlUrl + '/artifacts'} onClick={(e) => { e.stopPropagation(); run(\`open "\${r.htmlUrl}/artifacts"\`); }}>Artifacts</a></span>}
                        </span>
                        <span style={{
                          width: 7, height: 7, borderRadius: '50%', display: 'inline-block', cursor: 'pointer',
                          backgroundColor: dotColor,
                          animation: r.status !== 'completed' ? 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite' : 'none',
                        }} />
                      </span>
                    )})}
                    {runs.length === 0 && <span style={{color: '#4b5563', fontSize: '9px'}}>no runs</span>}
                  </div>
                  <span style={{fontSize: '9px', color: '#9ca3af', marginLeft: 'auto'}}>{g.passRate}%</span>
                </div>
                );
              })}
            </div>
          );
        })}${wrapClose}
};`

    case 'gpu_overview':
      return `
export const render = ({ output }) => {${parseBlock}

  if (error) {${wrapOpen}
        <div style={styles.cardTitle}>
          <span style={{...styles.statusDot, backgroundColor: styles.colors.error}} />
          ${card.displayName}
        </div>
        <span style={{color: styles.colors.error}}>Error: {error}</span>${wrapClose}
  }

  const nodes = data?.nodes || data || [];
  const totalGPUs = nodes.reduce((sum, n) => sum + (n.gpuCount || 0), 0);
  const allocatedGPUs = nodes.reduce((sum, n) => sum + (n.gpuAllocated || 0), 0);
  const utilization = totalGPUs > 0 ? Math.round((allocatedGPUs / totalGPUs) * 100) : 0;
${wrapOpen}
        <div style={styles.cardTitle}>
          <span style={{...styles.statusDot, backgroundColor: styles.colors.purple}} />
          ${card.displayName}
        </div>
        <div style={{textAlign: 'center', marginBottom: '12px'}}>
          <div style={{fontSize: '32px', fontWeight: 700, color: styles.colors.purple}}>{utilization}%</div>
          <div style={{fontSize: '12px', color: '#9ca3af'}}>Utilization</div>
        </div>
        <div style={styles.row}>
          <div style={styles.statBlock}>
            <span style={styles.statValue}>{totalGPUs}</span>
            <span style={styles.statLabel}>Total</span>
          </div>
          <div style={styles.statBlock}>
            <span style={{...styles.statValue, color: styles.colors.purple}}>{allocatedGPUs}</span>
            <span style={styles.statLabel}>Allocated</span>
          </div>
        </div>${wrapClose}
};`

    default:
      return `
export const render = ({ output }) => {${parseBlock}

  if (error) {${wrapOpen}
        <div style={styles.cardTitle}>${title}</div>
        <span style={{color: styles.colors.error}}>Error: {error}</span>${wrapClose}
  }
${wrapOpen}
        <div style={styles.cardTitle}>${title}</div>
        <pre style={{fontSize: '10px', overflow: 'auto', maxHeight: '100px'}}>
          {JSON.stringify(data, null, 2)}
        </pre>${wrapClose}
};`
  }
}

// Generate Übersicht widget code for stat blocks
export function generateStatWidget(
  statIds: string[],
  apiEndpoint: string,
  refreshInterval: number = 60000,
  layout: 'row' | 'grid' = 'row'
): string {
  const stats = statIds.map((id) => WIDGET_STATS[id]).filter(Boolean)
  if (stats.length === 0) {
    throw new Error('No valid stat IDs provided')
  }

  // For stats we use the first endpoint (most stat widgets share one)
  const endpoint = `${apiEndpoint}${stats[0].apiEndpoint}`

  return `/**
 * Stats Widget
 * Displays: ${stats.map((s) => s.displayName).join(', ')}
 *
 * Generated by KubeStellar Console
 */

// Fetch data via curl (Übersicht's WebKit does not support fetch)
export const command = \`/usr/bin/curl -s --connect-timeout 5 ${endpoint} 2>/dev/null || echo '{"error":"Load failed"}'\`;

export const refreshFrequency = ${refreshInterval};

${generateWidgetStyles()}

const StatBlock = ({ value, label, color }) => (
  <div style={{...styles.statBlock, borderTop: \`3px solid \${color}\`}}>
    <span style={{...styles.statValue, color}}>{value}</span>
    <span style={styles.statLabel}>{label}</span>
  </div>
);

export const render = ({ output }) => {
  let data = null;
  let error = null;
  try {
    const trimmed = (output || '').trim();
    if (!trimmed || trimmed.includes('"error"')) {
      error = 'Load failed';
    } else {
      data = JSON.parse(trimmed);
    }
  } catch (e) {
    error = 'Parse error';
  }

  if (error) {
    return <div style={styles.row}><span style={{color: styles.colors.error}}>Error</span></div>;
  }

  // Extract values from API responses
  const getData = (path, src) => {
    try {
      return path.split('.').reduce((o, k) => o[k], src) || 0;
    } catch {
      return 0;
    }
  };

  return (
    <div style={{...styles.${layout}, ${layout === 'grid' ? "gridTemplateColumns: 'repeat(2, 1fr)'" : ''}}}>
      ${stats
        .map((stat) => {
          return `<StatBlock
        value={getData('${stat.dataPath}', data)}
        label="${stat.displayName}"
        color="${stat.color}"
      />`
        })
        .join('\n      ')}
    </div>
  );
};
`
}

// Generate Übersicht widget code for a template
export function generateTemplateWidget(
  templateId: string,
  apiEndpoint: string,
  refreshInterval: number = 30000
): string {
  const template = WIDGET_TEMPLATES[templateId]
  if (!template) {
    throw new Error(`Unknown template: ${templateId}`)
  }

  const allEndpoints: string[] = []

  // Collect endpoints from cards
  template.cards.forEach((cardType) => {
    const card = WIDGET_CARDS[cardType]
    if (card) {
      card.apiEndpoints.forEach((ep) => {
        if (!allEndpoints.includes(ep)) {
          allEndpoints.push(ep)
        }
      })
    }
  })

  // Collect endpoints from stats
  template.stats?.forEach((statId) => {
    const stat = WIDGET_STATS[statId]
    if (stat && !allEndpoints.includes(stat.apiEndpoint)) {
      allEndpoints.push(stat.apiEndpoint)
    }
  })

  // For templates, use the first endpoint (primary data source)
  const curlUrl = `${apiEndpoint}${allEndpoints[0]}`

  return `/**
 * ${template.displayName} Widget
 * ${template.description}
 *
 * Includes: ${[...template.cards, ...(template.stats || [])].join(', ')}
 * Generated by KubeStellar Console
 */

// Fetch data via curl (Übersicht's WebKit does not support fetch)
export const command = \`/usr/bin/curl -s --connect-timeout 5 ${curlUrl} 2>/dev/null || echo '{"error":"Load failed"}'\`;

export const refreshFrequency = ${refreshInterval};

${generateWidgetStyles()}

// Sub-components for each card/stat
${template.cards.map((cardType) => generateMiniCardComponent(cardType)).join('\n\n')}

${template.stats?.map((statId) => generateMiniStatComponent(statId)).join('\n\n') || ''}

export const render = ({ output }) => {
  let data = null;
  let error = null;
  try {
    const trimmed = (output || '').trim();
    if (!trimmed || trimmed.includes('"error"')) {
      error = 'Load failed';
    } else {
      data = JSON.parse(trimmed);
    }
  } catch (e) {
    error = 'Parse error';
  }

  if (error) {
    return <div style={styles.card}><span style={{color: styles.colors.error}}>Error: {error}</span></div>;
  }

  return (
    <div style={{...styles.card, ...styles.${template.layout}${template.layout === 'grid' ? `, gridTemplateColumns: 'repeat(${template.gridCols || 2}, 1fr)'` : ''}}}>
      ${template.stats && template.stats.length > 0 ? `<div style={styles.row}>\n        ${template.stats.map((statId) => `<${statId.replace(/_/g, '')}Stat data={data} />`).join('\n        ')}\n      </div>` : ''}
      ${template.cards.map((cardType) => `<${cardType.replace(/_/g, '')}Card data={data} />`).join('\n      ')}
    </div>
  );
};
`
}

// Generate mini card component for templates
function generateMiniCardComponent(cardType: string): string {
  const card = WIDGET_CARDS[cardType]
  if (!card) return ''

  const componentName = cardType.replace(/_/g, '') + 'Card'

  switch (cardType) {
    case 'cluster_health':
      return `const ${componentName} = ({ data }) => {
  const clusters = data?.clusters || [];
  const healthy = clusters.filter(c => c.healthy !== false).length;
  return (
    <div style={{...styles.statBlock, flex: 1}}>
      <span style={{...styles.statValue, color: styles.colors.healthy}}>{healthy}/{clusters.length}</span>
      <span style={styles.statLabel}>Clusters</span>
    </div>
  );
};`

    case 'pod_issues':
      return `const ${componentName} = ({ data }) => {
  const issues = data?.issues || [];
  return (
    <div style={{...styles.statBlock, flex: 1, borderLeft: issues.length > 0 ? '3px solid ' + styles.colors.warning : '3px solid ' + styles.colors.healthy}}>
      <span style={{...styles.statValue, color: issues.length > 0 ? styles.colors.warning : styles.colors.healthy}}>{issues.length}</span>
      <span style={styles.statLabel}>Pod Issues</span>
    </div>
  );
};`

    case 'gpu_overview':
      return `const ${componentName} = ({ data }) => {
  const nodes = data?.nodes || [];
  const total = nodes.reduce((s, n) => s + (n.gpuCount || 0), 0);
  return (
    <div style={{...styles.statBlock, flex: 1}}>
      <span style={{...styles.statValue, color: styles.colors.purple}}>{total}</span>
      <span style={styles.statLabel}>GPUs</span>
    </div>
  );
};`

    default:
      return `const ${componentName} = ({ data }) => (
  <div style={{...styles.statBlock, flex: 1}}>
    <span style={styles.statLabel}>${card.displayName}</span>
  </div>
);`
  }
}

// Generate mini stat component for templates
function generateMiniStatComponent(statId: string): string {
  const stat = WIDGET_STATS[statId]
  if (!stat) return ''

  const componentName = statId.replace(/_/g, '') + 'Stat'

  return `const ${componentName} = ({ data }) => {
  const value = (() => {
    try {
      return ${stat.dataPath.includes('reduce') || stat.dataPath.includes('filter') ? `(data?.${stat.dataPath.split('.')[0]} || []).${stat.dataPath.split('.').slice(1).join('.')}` : `data?.${stat.dataPath}`} || 0;
    } catch { return 0; }
  })();
  return (
    <div style={{...styles.statBlock, borderTop: '2px solid ${stat.color}'}}>
      <span style={{...styles.statValue, fontSize: '18px', color: '${stat.color}'}}>{value}${stat.format === 'percentage' ? '%' : ''}</span>
      <span style={{...styles.statLabel, fontSize: '9px'}}>${stat.displayName}</span>
    </div>
  );
};`
}

// Main generator function
export function generateWidget(config: WidgetConfig): string {
  switch (config.type) {
    case 'card':
      if (!config.cardType) throw new Error('cardType required for card widget')
      return generateCardWidget(config.cardType, config.apiEndpoint, config.refreshInterval)

    case 'stat':
      if (!config.statIds || config.statIds.length === 0) throw new Error('statIds required for stat widget')
      return generateStatWidget(config.statIds, config.apiEndpoint, config.refreshInterval)

    case 'template':
      if (!config.templateId) throw new Error('templateId required for template widget')
      return generateTemplateWidget(config.templateId, config.apiEndpoint, config.refreshInterval)

    default:
      throw new Error(`Unknown widget type: ${config.type}`)
  }
}

// Get filename for widget
export function getWidgetFilename(config: WidgetConfig): string {
  switch (config.type) {
    case 'card':
      return `${config.cardType?.replace(/_/g, '-')}.widget.jsx`
    case 'stat':
      return `stats-${config.statIds?.join('-')}.widget.jsx`
    case 'template':
      return `${config.templateId?.replace(/_/g, '-')}.widget.jsx`
    default:
      return 'widget.jsx'
  }
}
